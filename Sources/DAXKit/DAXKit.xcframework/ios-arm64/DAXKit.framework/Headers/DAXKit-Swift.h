#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
#ifndef DAXKIT_SWIFT_H
#define DAXKIT_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wduplicate-method-match"
#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if defined(__cplusplus)
#if !defined(SWIFT_NOEXCEPT)
# define SWIFT_NOEXCEPT noexcept
#endif
#else
#if !defined(SWIFT_NOEXCEPT)
# define SWIFT_NOEXCEPT 
#endif
#endif
#if defined(__cplusplus)
#if !defined(SWIFT_CXX_INT_DEFINED)
#define SWIFT_CXX_INT_DEFINED
namespace swift {
using Int = ptrdiff_t;
using UInt = size_t;
}
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="DAXKit",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
@class NSString;

/// Protocol for a class that can provide a valid access token for the DAXKit to stream up to the DAX Servers
SWIFT_PROTOCOL("_TtP6DAXKit19AccessTokenProvider_")
@protocol AccessTokenProvider
/// Function that is called by DAXKit to retrieve an access token
/// \param onSuccess the callback that should return the token if the provider can retrieve it.
///
/// \param onFailure the callback that returns an error indicating that retrieving access token was unsuccessful.
///
- (void)accessTokenOnSuccess:(void (^ _Nonnull)(NSString * _Nonnull))onSuccess onFailure:(void (^ _Nonnull)(NSError * _Nonnull))onFailure;
@end

typedef SWIFT_ENUM(NSInteger, AdministrativeGender, open) {
  AdministrativeGenderUnspecified = 0,
  AdministrativeGenderMale = 1,
  AdministrativeGenderFemale = 2,
  AdministrativeGenderOther = 3,
  AdministrativeGenderUnknown = 4,
};


/// Protocol for a class that provides metadata about the app that is using the DAXKit.
SWIFT_PROTOCOL("_TtP6DAXKit19AppMetadataProvider_")
@protocol AppMetadataProvider
/// The bundle identifier for the app that is using DAXKit
@property (nonatomic, readonly, copy) NSString * _Nonnull appID;
/// The current version of the app that is using DAXKit.
@property (nonatomic, readonly, copy) NSString * _Nonnull appVersion;
/// A unique identifier for this device. Ideally this is as fixed as possible.
/// Commonly the <a href="https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor">identifierForVendor</a> is used.
@property (nonatomic, readonly, copy) NSString * _Nonnull deviceID;
@end

enum AudioInputDeviceType : NSInteger;

/// Structure representing audio input device used for the current recording
SWIFT_CLASS("_TtC6DAXKit16AudioInputDevice")
@interface AudioInputDevice : NSObject
- (nonnull instancetype)initWithType:(enum AudioInputDeviceType)type name:(NSString * _Nonnull)name OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Type of audio input device used for the recording
typedef SWIFT_ENUM(NSInteger, AudioInputDeviceType, open) {
/// The device’s built-in microphone.
  AudioInputDeviceTypeBuiltInMic = 0,
/// An input device recognized by the system, but not the built-in microphone.
  AudioInputDeviceTypeOther = 1,
};



@protocol DAXKitDelegate;
@class EHRData;
@class WorkflowSettings;
@class NSLocale;
@class DAXSession;

SWIFT_CLASS("_TtC6DAXKit3DAX")
@interface DAX : NSObject
/// Singleton instance of the DAXKit framework
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) DAX * _Nonnull shared;)
+ (DAX * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// Initializes the DAXKit SDK. This needs to be called prior to attempting to interact with the DAXKit framework.
/// Throws an error if it fails to initialize the SDK or if the method is called again to update the server environment without a restart.
/// \param appMetadataProvider Object that will provide information about the app that is using DAXKit
///
/// \param accessTokenProvider Object that will provide access tokens to speak with DAX servers
///
/// \param delegate Delegate to receive notification of successful uploads
///
/// \param partnerId Partner indentifier per ehr company
///
+ (BOOL)startWithAppMetadataProvider:(id <AppMetadataProvider> _Nonnull)appMetadataProvider accessTokenProvider:(id <AccessTokenProvider> _Nonnull)accessTokenProvider delegate:(id <DAXKitDelegate> _Nonnull)delegate partnerId:(NSString * _Nonnull)partnerId error:(NSError * _Nullable * _Nullable)error;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Retrieve the DAXSession for the given unique identifier
/// \param identifier a unique identifier that is meant to be passed to the DAX servers
///
/// \param ehrData EHR data of the encounter
///
/// \param workflow workflow configuration of the encounter, if needed
///
/// \param reportLocale The locale for the AI-generated report. If not set, <code>reportLocale</code> defaults to <code>en-US</code>.
///
/// \param uxLocale The locale of the user interface. If not set, <code>uxLocale</code> defaults to <code>en-US</code>.
///
///
/// returns:
/// the DAXSession that can be used for starting recordings that are meant to be associated with the current patient encounter.
- (DAXSession * _Nonnull)sessionWithIdentifier:(NSString * _Nonnull)identifier ehrData:(EHRData * _Nullable)ehrData workflow:(WorkflowSettings * _Nonnull)workflow reportLocale:(NSLocale * _Nullable)reportLocale uxLocale:(NSLocale * _Nullable)uxLocale SWIFT_WARN_UNUSED_RESULT;
/// Configure the DAX SDK
/// <ul>
///   <li>
///     Throws Returns errors if incorrect types are passed for keys
///   </li>
/// </ul>
/// \param configuration Dictionary of configuration options with available keys defined in DAX.ConfigurationKeys
///
- (BOOL)configure:(NSDictionary<NSString *, id> * _Nonnull)configuration error:(NSError * _Nullable * _Nullable)error;
/// Disable logging for DaxKit and SpokeLoggers
- (void)disableLogging;
/// Ensure that the application is ready to record.
/// This will prompt the user to give permission if they haven’t yet given
- (BOOL)prepareToRecordAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Allows DAX SDK to retry uploads which have failed
///
/// throws:
/// If DAX SDK hasn’t been configured with a valid user an error will be thrown
- (BOOL)resumeUploadsAndReturnError:(NSError * _Nullable * _Nullable)error;
/// Pauses uploads until <code>resumeUploads</code> is called.
/// Please note that current in progress upload will be let to complete (with either success or failure).
- (void)pauseUploads;
/// Clears all of daxkit’s local data
/// CoreData objects, Encryption Keys and any associated daxkit files
- (void)clearData;
@end


/// List of keys that can be used with the <code>configure()</code> method
SWIFT_CLASS_NAMED("ConfigurationKeys")
@interface DAXConfigurationKeys : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Collection of keys that are used to identify the currently active user
SWIFT_CLASS_NAMED("Provider")
@interface DAXConfigurationKeysProvider : NSObject
/// DAX Specific user identifier. Associated Value Type: String
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull userId;)
+ (NSString * _Nonnull)userId SWIFT_WARN_UNUSED_RESULT;
/// User email. Associated Value Type: String
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull email;)
+ (NSString * _Nonnull)email SWIFT_WARN_UNUSED_RESULT;
/// EMR specific user identifier. Associated Value Type: String
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull emrId;)
+ (NSString * _Nonnull)emrId SWIFT_WARN_UNUSED_RESULT;
/// User’s name. Associated Value Type: String
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull name;)
+ (NSString * _Nonnull)name SWIFT_WARN_UNUSED_RESULT;
/// Org id from NMS. Associated Value Type: String
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull orgId;)
+ (NSString * _Nonnull)orgId SWIFT_WARN_UNUSED_RESULT;
/// Associated DAX product. Associated Value Type: String
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull productId;)
+ (NSString * _Nonnull)productId SWIFT_WARN_UNUSED_RESULT;
/// Geography of the provider. Associated Value Type: String
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull geography;)
+ (NSString * _Nonnull)geography SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("ServerEnvironment")
@interface DAXConfigurationKeysServer : NSObject
/// Server environment to connect to. Associated Value Type: String
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull environment;)
+ (NSString * _Nonnull)environment SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Delegate for the framework that gets notified when a recording is successfully uploaded for an encounter
SWIFT_PROTOCOL("_TtP6DAXKit14DAXKitDelegate_")
@protocol DAXKitDelegate
/// Callback for when a recording is succesfully uploaded to the DAX servers.
/// \param recordingIdentifier The unique identifier for the specific recording that this callback is for
///
/// \param sessionIdentifier The session identifier for which the recording is meant to be associated with
///
- (void)uploadedRecordingWithRecordingIdentifier:(NSString * _Nonnull)recordingIdentifier sessionIdentifier:(NSString * _Nonnull)sessionIdentifier;
/// Callback for when a recording failed to upload to the DAX servers for some reason.
/// \param recordingIdentifier The unique identifier for the specific recording that this callback is for
///
/// \param sessionIdentifier The session identifier for which the recording is meant to be associated with
///
/// \param error Note that there should only ever be one success per recording identifier,
/// but there may be multiple errors if DAXKit attempts and fails multiple times to upload the recording.
///
/// \param willRetryUpload True in case the upload will be retried in the future,
/// False in case we encountered a non recoverable error during the upload, and no more attempts will be made.
///
- (void)uploadFailedWithRecordingIdentifier:(NSString * _Nonnull)recordingIdentifier sessionIdentifier:(NSString * _Nonnull)sessionIdentifier error:(NSError * _Nonnull)error willRetryUpload:(BOOL)willRetryUpload;
- (void)recordingPermissionWithGranted:(BOOL)granted;
/// Called when a recording has started uploading. Note it may be called multiple times
/// \param recordingIdentifier The unique identifier for the specific recording that this callback is for
///
/// \param sessionIdentifier The session identifier for which the recording is meant to be associated with
///
- (void)didStartUploadWithRecordingIdentifier:(NSString * _Nonnull)recordingIdentifier sessionIdentifier:(NSString * _Nonnull)sessionIdentifier;
/// Called when finished current upload and has no more pending recordings to upload.
- (void)didFinishAllUploads;
/// Called when the server has been notified that session has been completed
/// \param identifier The unique identifier for the session that was completed using <code>DAXSession.complete()</code>
///
- (void)didCompleteSessionWithIdentifier:(NSString * _Nonnull)identifier;
/// Called when request to complete session failed.
/// \param identifier The unique identifier of the session
///
/// \param error Error which occurred while attempting to complete session
///
- (void)didFailToCompleteSessionWithIdentifier:(NSString * _Nonnull)identifier withError:(NSError * _Nonnull)error;
/// Called to inform client about supported languages for recording and report
/// \param recordingLocales List of locales supported for recording
///
/// \param reportLocales List of locales supported for report
///
- (void)didReceiveSupportedLanguagesWithRecordingLocales:(NSArray<NSLocale *> * _Nonnull)recordingLocales reportLocales:(NSArray<NSLocale *> * _Nonnull)reportLocales;
@end

@protocol RecordingDelegate;
@class Recorder;

/// Struct that represents a single session. For each unique patient encounter: the identifier should be different.
/// However for multiple recordings for the same patient encounter the identifier should be the same.
SWIFT_CLASS("_TtC6DAXKit10DAXSession")
@interface DAXSession : NSObject
/// The unique identifier that provider assigns to the associated patient encounter.
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// Start a new recording for the given session.
/// If DAXKit successfully starts recording the delegate’s <code>recordingStarted</code> will be called.
/// If DAXKit fails to start recording, the delegate’s <code>recordingStopped(withError:)</code> will be called and the function will throw an error.
/// \param delegate The delegate that wishes to receive recording updates
///
/// \param locales One or more locales describing the language to be spoken in the recording. If <code>locales</code> is not set, the language is assumed to be US English (<code>en-US</code>).
///
/// \param autoNoteGeneration Determines whether the note is auto generated for this recording. If <code>autoNoteGeneration</code> is not set, it defaults to true.
///
///
/// throws:
/// If the recording fails to start due to a configuration error
///
/// returns:
/// A recorder object that can be used for stopping this recording
- (Recorder * _Nullable)startRecordingWithDelegate:(id <RecordingDelegate> _Nonnull)delegate locales:(NSArray<NSLocale *> * _Nonnull)locales autoNoteGeneration:(BOOL)autoNoteGeneration error:(NSError * _Nullable * _Nullable)error SWIFT_WARN_UNUSED_RESULT;
/// Completes the session
- (BOOL)completeAndReturnError:(NSError * _Nullable * _Nullable)error;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class Patient;

SWIFT_CLASS("_TtC6DAXKit7EHRData")
@interface EHRData : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable appointmentId;
@property (nonatomic, readonly, copy) NSString * _Nullable encounterId;
@property (nonatomic, readonly, copy) NSString * _Nullable mrn;
@property (nonatomic, readonly, strong) Patient * _Nullable patient;
@property (nonatomic, readonly, copy) NSString * _Nullable reasonForVisit;
- (nonnull instancetype)initWithAppointmentId:(NSString * _Nullable)appointmentId encounterId:(NSString * _Nullable)encounterId mrn:(NSString * _Nullable)mrn patient:(Patient * _Nullable)patient reasonForVisit:(NSString * _Nullable)reasonForVisit OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@class NSDate;

SWIFT_CLASS("_TtC6DAXKit7Patient")
@interface Patient : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable id;
@property (nonatomic, readonly, copy) NSString * _Nullable firstName;
@property (nonatomic, readonly, copy) NSString * _Nullable middleName;
@property (nonatomic, readonly, copy) NSString * _Nullable lastName;
@property (nonatomic, readonly, copy) NSDate * _Nullable dateOfBirth;
@property (nonatomic, readonly) enum AdministrativeGender gender;
- (nonnull instancetype)initWithId:(NSString * _Nullable)id firstName:(NSString * _Nullable)firstName middleName:(NSString * _Nullable)middleName lastName:(NSString * _Nullable)lastName dateOfBirth:(NSDate * _Nullable)dateOfBirth gender:(enum AdministrativeGender)gender OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Struct that represents a recorder for a specific encounter and recording. Provides the hook for manually stopping a recording.
SWIFT_CLASS("_TtC6DAXKit8Recorder")
@interface Recorder : NSObject
/// Stop the recording. It will throw an error if it fails for any reason.
/// Note that it will also trigger the delegate’s <code>recordingStopped()</code> function if it failed.
- (BOOL)stopAndReturnError:(NSError * _Nullable * _Nullable)error;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum RecordingInterruptionReason : NSInteger;

/// Delegate for receiving Recording start and stop events
SWIFT_PROTOCOL("_TtP6DAXKit17RecordingDelegate_")
@protocol RecordingDelegate
/// Callback to let user know we started to record.
/// \param recordingIdentifier The unique identifier of the recording
///
/// \param sessionIdentifier The correlation identifier of the encounter
///
/// \param audioInputDevice The audio input device used for current recording
///
- (void)didStartRecordingWithRecordingIdentifier:(NSString * _Nonnull)recordingIdentifier sessionIdentifier:(NSString * _Nonnull)sessionIdentifier audioInputDevice:(AudioInputDevice * _Nonnull)audioInputDevice;
/// Callback to let user know we failed to create a new recording.
/// \param sessionIdentifier The unique identifier of the encounter
///
/// \param error The error associated with start recording
///
- (void)didFailToStartRecordingWithSessionIdentifier:(NSString * _Nonnull)sessionIdentifier error:(NSError * _Nonnull)error;
/// Callback to let user know we stopped recording.
/// \param recordingIdentifier The unique identifier of the recording
///
/// \param sessionIdentifier The correlation identifier of the encounter
///
/// \param recordingDuration The duration of audio, recorded for the recording
///
- (void)didStopRecordingWithRecordingIdentifier:(NSString * _Nonnull)recordingIdentifier sessionIdentifier:(NSString * _Nonnull)sessionIdentifier recordingDuration:(NSTimeInterval)recordingDuration;
/// Callback to let user know the device is recording digital silence
- (void)digitalSilenceDetected;
/// Callback for when a recording is interrupted for any reason
/// \param reason Reason for the recording being interrupted
///
- (void)recordingInterruptedWithReason:(enum RecordingInterruptionReason)reason;
/// Callback for when a session has come close to its max recording duration.
/// \param timeLeft Amount of time left available to record on the given session across all recordings.
///
- (void)reachedWarnDurationWithTimeLeft:(NSTimeInterval)timeLeft;
/// Callback to update current recording length and audio level.
/// Called with 0.1 seconds intervals during the recording. Not called when there is no active recording.
/// \param duration duration of current ongoing recording in seconds.
///
/// \param audioLevel value between 0 and 1 representing audio level of the current audio interval.
///
- (void)recordedAudioWithDuration:(NSTimeInterval)duration audioLevel:(float)level;
@end

/// Why a recording was interrupted
typedef SWIFT_ENUM(NSInteger, RecordingInterruptionReason, open) {
/// There was an audio interruption caused by someone taking over the audio system.
  RecordingInterruptionReasonAudioInterruption = 0,
/// There was a system error that caused the recording to prematurely complete.
  RecordingInterruptionReasonSystemError = 1,
/// Reached the maximum recording duration for the encounter.
  RecordingInterruptionReasonReachedMaxDuration = 2,
/// The input device is not compatible with the current recording configuration.
  RecordingInterruptionReasonIncompatibleInputDevice = 3,
/// There was a change in the audio input device, causing the recording to stop.
  RecordingInterruptionReasonAudioRouteChanged = 4,
};




SWIFT_CLASS_NAMED("Version")
@interface DAXVersion : NSObject
/// The major version.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger major;)
+ (NSInteger)major SWIFT_WARN_UNUSED_RESULT;
/// The minor version.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger minor;)
+ (NSInteger)minor SWIFT_WARN_UNUSED_RESULT;
/// The patch version.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) NSInteger patch;)
+ (NSInteger)patch SWIFT_WARN_UNUSED_RESULT;
/// The label. eg - dev
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nullable label;)
+ (NSString * _Nullable)label SWIFT_WARN_UNUSED_RESULT;
/// The version string.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull versionString;)
+ (NSString * _Nonnull)versionString SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6DAXKit16WorkflowSettings")
@interface WorkflowSettings : NSObject
@property (nonatomic, readonly) BOOL deliverOnceOnSessionComplete;
- (nonnull instancetype)initWithDeliverOnceOnSessionComplete:(BOOL)deliverOnceOnSessionComplete OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#endif
#if defined(__cplusplus)
#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
